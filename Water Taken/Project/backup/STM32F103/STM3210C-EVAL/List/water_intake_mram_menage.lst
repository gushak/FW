###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       24/Apr/2019  16:42:23
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\water_intake_mram_menage.c
#    Command line =  
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\water_intake_mram_menage.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210C_EVAL -lcN
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\STM3210C-EVAL\List
#        --diag_suppress pa082 -o
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\STM3210C-EVAL\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Full.h" -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\ -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Utilities\STM32_EVAL\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Utilities\STM32_EVAL\STM3210C_EVAL\
#        -Ohs --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Korean_Korea.949
#    List file    =  
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\STM3210C-EVAL\List\water_intake_mram_menage.lst
#    Object file  =  
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\STM3210C-EVAL\Obj\water_intake_mram_menage.o
#
###############################################################################

D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\water_intake_mram_menage.c
      1          #include "hw_control.h"
      2          #include "spi_flash.h"
      3          
      4          #define MRAM_MAX_ADDRESS	(0x8000 - 1)
      5          
      6          #define MRAM_INTAKE_START_ADDRESS	0x100
      7          #define MRAM_INTAKE_HEAD_ADDRESS		0x06
      8          
      9          #define MRAM_EEPROM_ADDRESS	0x10
     10          
     11          volatile uint16_t Mram_intake_address[MRAM_INTAKE_MAX_ADDRESS];
     12          
     13          
     14          volatile uint8_t itemp = 0xfa, xtemp = 0;
     15          volatile uint8_t status = 0;
     16          volatile uint32_t wadr = 1;
     17          volatile uint32_t radr = 2;
     18          volatile uint8_t lp = 1;
     19          volatile uint8_t dat = 1;
     20          volatile uint8_t wd[10];
     21          volatile uint8_t rd[10];
     22          
     23          void mram_test(void)
     24          {
     25          	
     26          	while(1)
     27          	{		
     28          		if(lp==1)
     29          		{
     30          			lp = 0;			
     31          			status = SPI_FLASH_PageWrite((uint8_t*)&wd, wadr, 10);	Delay(1);				
     32          			Delay(10);		
     33          			
     34          		}
     35          		SPI_FLASH_BufferRead((uint8_t*)&rd, radr, 10);
     36          		Delay(10);
     37          	}
     38          }
     39          
     40          
     41          uint16_t Intake_Head(void)
     42          {
     43          	//mram에서 값 읽어오기 
     44          	uint16_t ret;
     45          	//mram코드 작성예정 ~!!
     46          	SPI_FLASH_BufferRead((uint8_t*)&ret, MRAM_INTAKE_HEAD_ADDRESS, 2);
     47          	if(ret >= MRAM_INTAKE_MAX_ADDRESS) ret = 0;
     48          	return ret;
     49          }
     50          
     51          void Intake_head_increment()
     52          {
     53          	uint16_t head = Intake_Head() + 1;
     54          	
     55          	if(head > MRAM_INTAKE_MAX_ADDRESS) head = 0;	
     56          	SPI_FLASH_PageWrite((uint8_t*)&head, MRAM_INTAKE_HEAD_ADDRESS, 2);
     57          }
     58          
     59          void Intake_page_all_init()
     60          {
     61          	uint16_t i=0;
     62          	WATER_ITAKE_TABLE_STRUCT w_intake_clear;
     63          	
     64          	memset((void *)&w_intake_clear, 0, sizeof(w_intake_clear));
     65          	
     66          	for(i=0;i<MRAM_INTAKE_MAX_ADDRESS;i++)
     67          	{
     68          		w_intake_clear.index = i;		
     69          		SPI_FLASH_PageWrite((uint8_t *)&w_intake_clear,Mram_intake_address[i], sizeof(w_intake_clear));
     70          	}
     71          }
     72          
     73          void Intake_page_all_enable()
     74          {
     75          	uint16_t i=0;
     76          	WATER_ITAKE_TABLE_STRUCT w_intake_enable;
     77          	
     78          	
     79          	
     80          	for(i=0;i<MRAM_INTAKE_MAX_ADDRESS;i++)
     81          	{
     82          		memset((void *)&w_intake_enable, 0, sizeof(w_intake_enable));
     83          		
     84          		SPI_FLASH_BufferRead((uint8_t *)&w_intake_enable,Mram_intake_address[i], sizeof(w_intake_enable));
     85          		
     86          		if(w_intake_enable.index != 0 && w_intake_enable.date != 0 && w_intake_enable.feeder_num != 0)
     87          		{
     88          			w_intake_enable.status |= 0x01;		
     89          			SPI_FLASH_PageWrite((uint8_t *)&w_intake_enable,Mram_intake_address[i], sizeof(w_intake_enable));
     90          		}
     91          	}
     92          }
     93          
     94          
     95          
     96          
     97          //데이타 초기화 하기!!
     98          //
     99          //
    100          
    101          
    102          
    103          #ifdef MRAM_EEPROM_ENABLE
    104          
    105          void lll_eeprom_init(void)
    106          {
    107          	uint16_t i=0;
    108          	Mram_intake_address[0] = MRAM_INTAKE_START_ADDRESS;		//0x0004813C
    109          	for(i=1;i<MRAM_INTAKE_MAX_ADDRESS;i++)
    110          	{
    111          			Mram_intake_address[i] = Mram_intake_address[i-1] + sizeof(WATER_ITAKE_TABLE_STRUCT);
    112          	}	
    113          	//mram_init
    114          }
    115          
    116          void eeprom_default_value(void)		
    117          {
    118          	//Menu_test = 101;
    119          	CON_ADDRESS = CON_ADDRESS_DEFAULT;		
    120          	CON_WATER_WAIT_TIME = CON_WATER_WAIT_TIME_DEFAULT;
    121          	CON_WATER_WAIT_DIFF = CON_WATER_WAIT_DIFF_DEFAULT;
    122          	CON_COWIN_IR_CNT = CON_COWIN_IR_CNT_DEFAULT;
    123          	CON_COWIN_RFID_CNT = CON_COWIN_RFID_CNT_DEFAULT;
    124          	COM_RE_ENTER_CNT = COM_RE_ENTER_CNT_DEFAULT;	
    125          
    126          
    127          		
    128          	Intake_page_all_init();	//mram clear
    129          }
    130          
    131          void load_eeprom(void)
    132          {
    133          	SPI_FLASH_BufferRead((uint8_t*)&Config, MRAM_EEPROM_ADDRESS, sizeof(Config));
    134          	
    135          	if(Config.setup != EEPROM_CHECK_VALUE)
    136          	{
    137          		Config.setup = EEPROM_CHECK_VALUE;
    138          		eeprom_default_value(); 
    139          		save_all_eeprom(); 	
    140          		
    141          		TM_HD44780_Puts(0,0,"EEPROM DEFAULT  ");
    142          		TM_HD44780_Puts(0,1," Water Weight   ");
    143          		Delay(1000);
    144          		
    145          	} 
    146          	else
    147          	{
    148          		TM_HD44780_Puts(0,0,"EEPROM OK       ");
    149          		TM_HD44780_Puts(0,1," Water Weight   ");
    150          		Delay(1000);
    151          	}
    152          }
    153          
    154          void save_all_eeprom(void)
    155          {
    156          	Config.setup = EEPROM_CHECK_VALUE;
    157          	SPI_FLASH_PageWrite((uint8_t*)&Config, MRAM_EEPROM_ADDRESS, sizeof(Config));
    158          }
    159          
    160          
    161          
    162          #endif
    163          
    164          
    165          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Intake_Head
         8   -> SPI_FLASH_BufferRead
       8   Intake_head_increment
         8   -> SPI_FLASH_BufferRead
         8   -> SPI_FLASH_PageWrite
      40   Intake_page_all_enable
        40   -> SPI_FLASH_BufferRead
        40   -> SPI_FLASH_PageWrite
      40   Intake_page_all_init
        40   -> SPI_FLASH_PageWrite
      40   eeprom_default_value
        40   -> SPI_FLASH_PageWrite
       0   lll_eeprom_init
      48   load_eeprom
        48   -> Delay
        48   -> SPI_FLASH_BufferRead
        48   -> SPI_FLASH_PageWrite
        48   -> TM_HD44780_Puts
       8   mram_test
         8   -> Delay
         8   -> SPI_FLASH_BufferRead
         8   -> SPI_FLASH_PageWrite
       0   save_all_eeprom
         0   -> SPI_FLASH_PageWrite


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
      20  ?_0
      20  ?_1
      20  ?_2
      36  Intake_Head
      68  Intake_head_increment
      84  Intake_page_all_enable
      46  Intake_page_all_init
     400  Mram_intake_address
       1  dat
      78  eeprom_default_value
       1  itemp
      48  lll_eeprom_init
     148  load_eeprom
      60  mram_test
      16  save_all_eeprom
      36  status
          lp
          wadr
          radr
          wd
          rd
       1  xtemp

 
 401 bytes in section .bss
  38 bytes in section .data
 656 bytes in section .text
 
 656 bytes of CODE memory
 439 bytes of DATA memory

Errors: none
Warnings: none
