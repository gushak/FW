###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       24/Apr/2019  16:42:23
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\w_weight.c
#    Command line =  
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\w_weight.c -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210C_EVAL -lcN
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\STM3210C-EVAL\List
#        --diag_suppress pa082 -o
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\STM3210C-EVAL\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Full.h" -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\ -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Utilities\STM32_EVAL\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Utilities\STM32_EVAL\STM3210C_EVAL\
#        -Ohs --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Korean_Korea.949
#    List file    =  
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\STM3210C-EVAL\List\w_weight.lst
#    Object file  =  
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\STM3210C-EVAL\Obj\w_weight.o
#
###############################################################################

D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\w_weight.c
      1          #include "hw_control.h"
      2          
      3          uint8_t Co2[5];
      4          uint8_t Temp[5];
      5          uint8_t Humidity[5];
      6          
      7          uint32_t response;
      8          uint16_t humidity,temperature;
      9          
     10          uint16_t Co2_value = 0;
     11          
     12          Wight_struct Parse_st;
     13          
     14          char Weight_Dim[10];
     15          volatile uint16_t Stable_weight_ch1 = 0, weight_ch1 = 0;
     16          volatile uint16_t Stable_weight_ch2 = 0, weight_ch2 = 0;
     17          
     18          void weight_ParseData_ch1(char* Buffer)
     19          {
     20          
     21          	char *token, *last;		
     22          	char*buf = NULL;
     23          	uint8_t tcnt = 0;
     24          	buf = Buffer;
     25          	
     26          	while((token = strtok_r(buf,",", &last))!= NULL)
     27          	{
     28          		buf = NULL;
     29          		
     30          		if(tcnt == 0) 
     31          			sprintf((char *)&Parse_st.name1, "%s", token);
     32          		else if(tcnt == 1)
     33          			sprintf((char *)&Parse_st.name2, "%s", token);
     34          		else if(tcnt == 2)
     35          			sprintf((char *)&Parse_st.name3, "%s", token);
     36          		else if(tcnt == 3)
     37          			sprintf((char *)&Parse_st.value, "%s", token);
     38          		
     39          		if(++tcnt >= 5) break;
     40          	}		
     41          
     42          	tcnt = 0;
     43          	uint8_t len = 0;
     44          	
     45          	memset((void *)&Weight_Dim, 0, sizeof(Weight_Dim));
     46          	for(int i=0; i < strlen((char const *)&Parse_st.value); i++)
     47          	{
     48          		if(Parse_st.value[i] >= '0' && Parse_st.value[i] <= '9')
     49          		{
     50          			Weight_Dim[len++] = Parse_st.value[i];
     51          			if(len >= 10) break;
     52          		}		
     53          	}
     54          	
     55          	//weight = atoi((const char *)&Weight_Dim);
     56          	weight_ch1 = atoi((const char *)&Weight_Dim);
     57          	
     58          	if(Parse_st.name1[1] == 'T') 
     59          	{
     60          		//LED1_FL;
     61          		//Stable_weight = weight;
     62          		Stable_weight_ch1 = weight_ch1;
     63          	}
     64          } 
     65          
     66          void weight_ParseData_ch2(char* Buffer)
     67          {
     68          
     69          	char *token, *last;		
     70          	char*buf = NULL;
     71          	uint8_t tcnt = 0;
     72          	buf = Buffer;
     73          	
     74          	while((token = strtok_r(buf,",", &last))!= NULL)
     75          	{
     76          		buf = NULL;
     77          		
     78          		if(tcnt == 0) 
     79          			sprintf((char *)&Parse_st.name1, "%s", token);
     80          		else if(tcnt == 1) 
     81          			sprintf((char *)&Parse_st.name2, "%s", token);
     82          		else if(tcnt == 2)
     83          			sprintf((char *)&Parse_st.name3, "%s", token);
     84          		else if(tcnt == 3)
     85          			sprintf((char *)&Parse_st.value, "%s", token);
     86          		
     87          		if(++tcnt >= 5) break;
     88          	}		
     89          
     90          	tcnt = 0;
     91          	uint8_t len = 0;
     92          	
     93          	memset((void *)&Weight_Dim, 0, sizeof(Weight_Dim));
     94          	for(int i=0; i < strlen((char const *)&Parse_st.value); i++)
     95          	{
     96          		if(Parse_st.value[i] >= '0' && Parse_st.value[i] <= '9')
     97          		{
     98          			Weight_Dim[len++] = Parse_st.value[i];
     99          			if(len >= 10) break;
    100          		}		
    101          	}
    102          	
    103          	weight_ch2 = atoi((const char *)&Weight_Dim);
    104          	
    105          	if(Parse_st.name1[1] == 'T') 
    106          	{
    107          		//LED1_FL;
    108          		Stable_weight_ch2 = weight_ch2;
    109          	}
    110          } 
    111          extern volatile uint8_t Stable_ch_flag;
    112          volatile char Wbuf[100];
    113          void parse_weight(void)
    114          {	
    115          	static uint8_t cntx = 0;
    116          	static uint8_t stable_ch_flag_old = 0;
    117          	static uint8_t dummy_cnt = 0;
    118          	
    119          	uint8_t c = 0;
    120          	if(!uart2_is_empty())
    121          	{
    122          		c = uart2_dequeue();
    123          		
    124          		if(c == 0x0A && cntx == 21) {
    125          			Wbuf[cntx] = 0x0A;
    126          					
    127          
    128          			if(stable_ch_flag_old != Stable_ch_flag)
    129          			{
    130          				dummy_cnt = 3;
    131          				stable_ch_flag_old = Stable_ch_flag;
    132          			}
    133          			else {		
    134          				if(dummy_cnt != 0) {
    135          					dummy_cnt--;
    136          				} else {
    137          					if(Stable_ch_flag != 0) weight_ParseData_ch1((char *)&Wbuf);
    138          					else weight_ParseData_ch2((char *)&Wbuf);
    139          				}
    140          			}
    141          			
    142          			cntx = 0;
    143          			memset((void *)&Wbuf, 0, sizeof(Wbuf));
    144          		} else if(cntx > 22) {
    145          			cntx = 0;
    146          			memset((void *)&Wbuf, 0, sizeof(Wbuf));
    147          		} else {
    148          			Wbuf[cntx++] = c;			
    149          		}
    150          
    151          		
    152          	}
    153          }
    154          
    155          void parse_weight_interrupt(uint8_t c)
    156          {
    157          	static uint8_t cntx = 0;
    158          #ifndef WEIGHT_SINGLE
    159          	static uint8_t stable_ch_flag_old = 0;
    160          	static uint8_t dummy_cnt = 0;
    161          #endif
    162          	
    163          	if(c == 0x0A && cntx >= 21) {
    164          		Wbuf[cntx] = 0x0A;
    165          					
    166          #ifdef WEIGHT_SINGLE
    167          			weight_ParseData_ch1((char *)&Wbuf);
    168          #else		
    169          		if(stable_ch_flag_old != Stable_ch_flag)
    170          		{
    171          			dummy_cnt = 1;
    172          			stable_ch_flag_old = Stable_ch_flag;
    173          		}
    174          		else {		
    175          			if(dummy_cnt != 0) {
    176          				dummy_cnt--;
    177          			} else {
    178          				if(Stable_ch_flag != 0) weight_ParseData_ch1((char *)&Wbuf);
    179          				else weight_ParseData_ch2((char *)&Wbuf);
    180          			}
    181          		}
    182          #endif
    183          		
    184          		cntx = 0;
    185          		memset((void *)&Wbuf, 0, sizeof(Wbuf));
    186          	} else if(cntx > 22) {
    187          		cntx = 0;
    188          		memset((void *)&Wbuf, 0, sizeof(Wbuf));
    189          	} else {
    190          		Wbuf[cntx++] = c;			
    191          	}		
    192          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   parse_weight
         0   -> __aeabi_memclr4
         8   -> uart2_dequeue
         8   -> uart2_is_empty
         8   -> weight_ParseData_ch1
         8   -> weight_ParseData_ch2
      16   parse_weight_interrupt
        16   -> __aeabi_memclr
        16   -> weight_ParseData_ch1
      32   weight_ParseData_ch1
        32   -> __aeabi_memclr4
        32   -> __iar_Stoul
        32   -> sprintf
        32   -> strlen
        32   -> strtok_r
      32   weight_ParseData_ch2
        32   -> __aeabi_memclr4
        32   -> __iar_Stoul
        32   -> sprintf
        32   -> strlen
        32   -> strtok_r


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ?_0
       2  ?_1
       8  Co2
       2  Co2_value
       8  Humidity
     100  Parse_st
          Stable_weight_ch1
          weight_ch1
          Stable_weight_ch2
          weight_ch2
          Weight_Dim
       8  Temp
     104  cntx
          stable_ch_flag_old
          dummy_cnt
          cntx
          Wbuf
       2  humidity
     110  parse_weight
      60  parse_weight_interrupt
       4  response
       2  temperature
     190  weight_ParseData_ch1
     190  weight_ParseData_ch2

 
 238 bytes in section .bss
   6 bytes in section .rodata
 570 bytes in section .text
 
 570 bytes of CODE  memory
   6 bytes of CONST memory
 238 bytes of DATA  memory

Errors: none
Warnings: none
