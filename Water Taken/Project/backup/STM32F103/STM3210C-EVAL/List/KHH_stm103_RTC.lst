###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       24/Apr/2019  16:42:18
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\KHH_stm103_RTC.c
#    Command line =  
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\KHH_stm103_RTC.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210C_EVAL -lcN
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\STM3210C-EVAL\List
#        --diag_suppress pa082 -o
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\STM3210C-EVAL\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Full.h" -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\ -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Utilities\STM32_EVAL\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\..\..\..\Utilities\STM32_EVAL\STM3210C_EVAL\
#        -Ohs --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Korean_Korea.949
#    List file    =  
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\STM3210C-EVAL\List\KHH_stm103_RTC.lst
#    Object file  =  
#        D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\STM3210C-EVAL\Obj\KHH_stm103_RTC.o
#
###############################################################################

D:\12.물섭취량조사기\5.Source\Project\backup\STM32F103\KHH_stm103_RTC.c
      1          #include "hw_control.h"
      2          
      3          
      4          volatile tm_struct Now;
      5          
      6          void RTC_Init(void)
      7          {
      8          	if (BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5)
      9          	{
     10          		//백업레지스터 값이 이상하다면~! 시간 설정
     11          		/* RTC Configuration */
     12          		RTC_Configuration();
     13          
     14          		Now.tm_year = 117; // 2017년
     15          		Now.tm_mon = 1;
     16          		Now.tm_mday = 2;
     17          		Now.tm_hour = 01;
     18          		Now.tm_min = 01;
     19          		Now.tm_sec = 01;
     20          		
     21          		Time_Adjust(Now);
     22          
     23          		BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);
     24          	}
     25          	else
     26          	{
     27          		/* Check if the Power On Reset flag is set */
     28          		if (RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET)
     29          		{
     30          			
     31          		}
     32          		/* Check if the Pin Reset flag is set */
     33          		else if (RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET)
     34          		{
     35          			
     36          		}
     37          		
     38          		/* Wait for RTC registers synchronization */
     39          		RTC_WaitForSynchro();
     40          
     41          		/* Enable the RTC Second */
     42          		//RTC_ITConfig(RTC_IT_SEC, ENABLE);		//인터럽트
     43          		/* Wait until last write operation on RTC registers has finished */
     44          		RTC_WaitForLastTask();
     45          	}
     46          
     47          	/* Clear reset flags */
     48          	RCC_ClearFlag();
     49          }
     50          
     51          void RTC_Configuration(void)
     52          {
     53          	/* Enable PWR and BKP clocks */
     54          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
     55          
     56          	/* Allow access to BKP Domain */
     57          	PWR_BackupAccessCmd(ENABLE);
     58          
     59          	/* Reset Backup Domain */
     60          	BKP_DeInit();
     61          
     62          	/* Enable LSE */
     63          	RCC_LSEConfig(RCC_LSE_ON);
     64          	/* Wait till LSE is ready */
     65          	while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
     66          	{}
     67          
     68          	/* Select LSE as RTC Clock Source */
     69          	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
     70          
     71          	/* Enable RTC Clock */
     72          	RCC_RTCCLKCmd(ENABLE);
     73          
     74          	/* Wait for RTC registers synchronization */
     75          	RTC_WaitForSynchro();
     76          
     77          	/* Wait until last write operation on RTC registers has finished */
     78          	RTC_WaitForLastTask();
     79          
     80          	/* Enable the RTC Second */
     81          	//RTC_ITConfig(RTC_IT_SEC, ENABLE);
     82          
     83          	/* Wait until last write operation on RTC registers has finished */
     84          	RTC_WaitForLastTask();
     85          
     86          	/* Set RTC prescaler: set RTC period to 1sec */
     87          	RTC_SetPrescaler(32767); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
     88          
     89          	/* Wait until last write operation on RTC registers has finished */
     90          	RTC_WaitForLastTask();
     91          }
     92          
     93          volatile uint32_t sec = 0;
     94          void Time_Adjust(tm_struct time)
     95          {
     96          	RTC_WaitForLastTask();
     97          	sec = RTC_DateToBinary(&time);
     98          	RTC_SetCounter(sec);
     99          	RTC_WaitForLastTask();
    100          }
    101          
    102          
    103          
    104          tm_struct read_RTC(void)
    105          {
    106          	tm_struct t;
    107          
    108          #if 0
    109          	// one day rtc
    110          	/* Reset RTC Counter when Time is 23:59:59 */
    111          	if (RTC_GetCounter() == 0x0001517F)
    112          	{
    113          		RTC_SetCounter(0x0);
    114          		/* Wait until last write operation on RTC registers has finished */
    115          		RTC_WaitForLastTask();
    116          	}
    117          #endif 
    118          
    119          	uint32_t TimeVar = RTC_GetCounter();
    120          	
    121          	RTC_BinaryToDate(TimeVar, &t);
    122          	
    123          
    124          	return t;	
    125          }
    126          
    127          void IntToDate(tm_struct *pDate, uint16_t Value)
    128          {
    129          	pDate->tm_mday = (Value&0x1F);
    130          	pDate->tm_mon = (Value>>5)&0xF;
    131          	pDate->tm_year = (Value>>(5+4))&0x3F;	
    132          	
    133          	pDate->tm_year += 100;		//since1900
    134          }
    135          
    136          uint16_t DateToInt(tm_struct *pDate)
    137          {
    138          	uint16_t value;
    139          	
    140          	pDate->tm_year = pDate->tm_year-100; 	//since 1900
    141          	if(pDate->tm_year < 0) pDate->tm_year = 0;
    142          	
    143          	value = (pDate->tm_year<<(5+4)) | (pDate->tm_mon<<5) | pDate->tm_mday;
    144          	return value;
    145          }
    146          
    147          uint16_t Get_Date(void)
    148          {
    149          	tm_struct t = read_RTC();
    150          	return DateToInt(&t);
    151          	
    152          }
    153          
    154          uint16_t GetTime_min(void)		//시간 * 60 + 분
    155          {
    156           	
    157          	tm_struct t = read_RTC();
    158          	
    159          	return (t.tm_hour * 60) + t.tm_min;		
    160          }
    161          
    162          uint16_t GetTime_sec(void)		//분 * 60 + 초
    163          {
    164           	
    165          	tm_struct t = read_RTC();
    166          	
    167          	return (t.tm_min * 60) + t.tm_sec;		
    168          }
    169          
    170          
    171          
    172          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DateToInt
      40   GetTime_min
        40   -> RTC_BinaryToDate
        40   -> RTC_GetCounter
      40   GetTime_sec
        40   -> RTC_BinaryToDate
        40   -> RTC_GetCounter
      40   Get_Date
        40   -> RTC_BinaryToDate
        40   -> RTC_GetCounter
       0   IntToDate
       8   RTC_Configuration
         8   -> BKP_DeInit
         8   -> PWR_BackupAccessCmd
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_GetFlagStatus
         8   -> RCC_LSEConfig
         8   -> RCC_RTCCLKCmd
         8   -> RCC_RTCCLKConfig
         8   -> RTC_SetPrescaler
         0   -> RTC_WaitForLastTask
         8   -> RTC_WaitForLastTask
         8   -> RTC_WaitForSynchro
      96   RTC_Init
        80   -> BKP_ReadBackupRegister
        80   -> BKP_WriteBackupRegister
         0   -> RCC_ClearFlag
        80   -> RCC_GetFlagStatus
        80   -> RTC_Configuration
        80   -> RTC_WaitForLastTask
        80   -> RTC_WaitForSynchro
        80   -> Time_Adjust
        96   -> __aeabi_memcpy4
      24   Time_Adjust
        24   -> RTC_DateToBinary
        24   -> RTC_SetCounter
        24   -> RTC_WaitForLastTask
      56   read_RTC
        56   -> RTC_BinaryToDate
        56   -> RTC_GetCounter


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      26  DateToInt
      32  GetTime_min
      32  GetTime_sec
      40  Get_Date
      22  IntToDate
      36  Now
      84  RTC_Configuration
     114  RTC_Init
      34  Time_Adjust
      30  read_RTC
       4  sec

 
  40 bytes in section .bss
 422 bytes in section .text
 
 422 bytes of CODE memory
  40 bytes of DATA memory

Errors: none
Warnings: none
