###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       24/May/2019  11:08:39
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\main.c
#    Command line =  
#        -f C:\Users\dawoon1\AppData\Local\Temp\EWF791.tmp
#        (D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\main.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210C_EVAL -lcN
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\STM3210C-EVAL\List
#        --diag_suppress pa082 -o
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\STM3210C-EVAL\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\
#        -I
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Utilities\STM32_EVAL\
#        -I
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Utilities\STM32_EVAL\STM3210C_EVAL\
#        -Ohs --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.0_2\arm\CMSIS\Core\Include\" -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0_2\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\STM3210C-EVAL\List\main.lst
#    Object file  =  
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\STM3210C-EVAL\Obj\main.o
#
###############################################################################

D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\main.c
      1          #include "hw_control.h"
      2          #include "water_intake.h"
      3          #include "Lora_parse.h"
      4          #define MAIN_LOOP_TIME       10
      5          #define VIEW_LOOP_TIME       100 
      6          #define CIRCLE_MAIN				10
      7          #define CAL_LOOP_TIME 		1000
      8          
      9          extern uint16_t VirtAddVarTab[NumbOfVar]; 
     10          extern WATER_ITAKE_TABLE_STRUCT Lora_wintake;
     11          extern Water_Info_t Weight;
     12          volatile uint8_t NFC_Reader_Ok = 0;
     13          volatile uint8_t Mode_flag = 0;
     14          volatile uint16_t Mode_delay = 0;
     15          volatile uint16_t FET_value[10]; 		
     16          volatile uint8_t Stable_run_flag = 0;
     17          uint8_t send_flag = 0;
     18          
     19          void lcd_view_init(void)
     20          {
     21          	TM_HD44780_Puts(0,0,"Dawoon 20170927 ");
     22          	TM_HD44780_Puts(0,1,"Water Intake    ");
     23          	Delay(2000);
     24          }
     25          uint8_t calibration_mode = 0;
     26          void setting(void)
     27          {	
     28          	lcd_view_init();
     29          	load_eeprom();
     30            lora_init();
     31          #if 0 
     32            uint8_t head = 1;
     33            SPI_FLASH_PageWrite((uint8_t*)&head, 0x06, 2);
     34          #endif
     35            
     36            uint8_t i = 0;
     37            uint32_t factor_addr = 0;
     38            factor_addr = (uint32_t)0x0800FC00;
     39            while(*(uint32_t*)factor_addr != 0xFFFFFFFF)
     40            {
     41            	Weight.value[i] = *(uint32_t*)factor_addr;
     42          	factor_addr = factor_addr+2;
     43          	i++;
     44            }
     45            Weight.factor = atof(Weight.value);
     46            Weight.factor = 2.9;
     47          }
     48          volatile uint32_t FET_sum[2];
     49          volatile uint16_t Input_cnt[4];
     50          volatile uint8_t k = 0;
     51          extern volatile uint8_t Input_value[2];
     52          extern volatile uint16_t Setting_delay;
     53          
     54          void timer_10ms_loop(void)
     55          {
     56              SW_check();
     57              
     58              if(Setting_delay != 0) Setting_delay--;	
     59              
     60          
     61              if(INPUT1 == 0) 
     62              { 	
     63                  if(	Input_cnt[0]++  > 2) 
     64                  {
     65                      Input_value[0] = 1;
     66                  } 
     67                  else 
     68                      Input_value[0] = 0;
     69                  
     70              } 
     71              else 
     72              {
     73                  Input_cnt[0] = 0;
     74                  Input_value[0] = 0;
     75              }	
     76              
     77              
     78              if(INPUT2 == 0) 
     79              {
     80                  if(	Input_cnt[1]++  > 2) 		
     81                  {
     82                      Input_value[1] = 1;
     83                  }	
     84                  else	
     85                      Input_value[1] = 0;	
     86              } 
     87              else 
     88              {
     89                  Input_cnt[1] = 0;
     90                  Input_value[1] = 0;
     91              }
     92          	
     93          	if(!R_IR_check())
     94          	{
     95          		FET_value[0] = 50;
     96          		FET_sum[0] = FET_value[0];
     97          		if(FET_sum[0] >=40000)
     98          		{			
     99          			//error_st.status = 0x01;
    100                                  //error_st.rf_id = rfid;
    101          			//Send_error_packet(&error_st);
    102          		}
    103          	}
    104          	
    105          	if(!R_IR_check2())
    106          	{
    107          		if(FET_sum[1] >= 20000)
    108          		{			
    109          			//error_st.status = 0x02;
    110                                  //error_st.rf_id = rfid;
    111          			//Send_error_packet(&error_st);
    112          		}
    113          	}	
    114              
    115              if(FET_value[0] != 0)
    116          	{ 
    117          		FET_value[0]--;   
    118          		FET1_ON; 
    119          	}
    120          	else
    121          	{   
    122          		FET_sum[0] = 0;
    123          		FET1_OFF; 
    124          	}	
    125              if(FET_value[1] != 0) 
    126          	{ 
    127          		FET_value[1]--; 
    128          	    FET2_ON; 
    129          	}
    130          	else 
    131          	{   
    132          		FET_sum[1] = 0;
    133          		FET2_OFF; 
    134          	}	//@@@
    135              if(FET_value[2] != 0) { FET_value[2]--;   FET3_ON; } else {   FET3_OFF; }	//@@ @@@@
    136              if(FET_value[3] != 0) { FET_value[3]--;   FET4_ON; } else {   FET4_OFF; }  //An Water supply 
    137              if(FET_value[4] != 0) { FET_value[4]--;   FET5_ON; } else {   FET5_OFF; }	    
    138          }
    139          
    140          
    141          
    142          extern uint8_t water_fill_delay;
    143          extern volatile uint16_t Stable_water_delay;
    144          
    145          volatile uint16_t FET_FL_cnt = 0;
    146          volatile uint16_t Stable_water_delay = 0;
    147          volatile uint8_t Stable_ch_flag = 0;
    148          
    149          extern volatile uint8_t  Oper_Cnt;		// @@ @@@
    150          
    151          volatile uint16_t Full_water_check_cnt = 0;
    152          volatile uint8_t FULL_Water_Error = 0;
    153          
    154          void timer_100ms_loop(void)
    155          {
    156          	if(tick > 0xFF) 
    157          		tick = 0;
    158          	else
    159          		tick--;
    160          	if(lora_tick > 0xFF)
    161          		lora_tick = 0;
    162          	else if(init_send)
    163          		lora_tick--;
    164          	
    165          	if(Mode_delay != 0) Mode_delay--;
    166          	if(water_fill_delay != 0) water_fill_delay--;
    167          	if(Stable_water_delay != 0) Stable_water_delay --;
    168          	
    169          }
    170          
    171          void timer_1000ms_loop(void)
    172          {
    173          	LED1_FL;
    174          }
    175          
    176          
    177          extern uint32_t pcnt , pcnt2, pweight;
    178          char buf_cnt_sensor[16];
    179          char buf_SW_fetvalue[16];
    180          char buf_menu_num[16];
    181          
    182          void main_view(void) 
    183          {
    184          	lcd_view_print();
    185          }
    186          
    187          volatile uint16_t test =0 ;
    188          
    189          void lcd_view_print(void)
    190          {
    191          	sprintf((char*)&buf_cnt_sensor, " %07d", pcnt);	
    192          	TM_HD44780_Puts(0,1, buf_cnt_sensor);	
    193          }
    194          
    195          void basic_mode(void)
    196          {
    197          	TM_HD44780_Puts(0,0, "DW_Water_Intake");	
    198          	TM_HD44780_Puts(0,1, "2017.09.22");	//>@@@@ 
    199          	
    200          	char buf[16] = {0,};
    201          	sprintf(buf, "%d", CON_ADDRESS);
    202          	TM_HD44780_Puts(10,1, buf); //>@@@@
    203          }
    204          
    205          
    206          void loop_main(void)
    207          {
    208          	#ifdef WATCHDOG_ENABLE
    209          	Wdt_reset();
    210          	#endif
    211          
    212          }
    213          
    214          volatile uint16_t send_rfid = 0;
    215          
    216          extern volatile uint8_t Setting_enable;    
    217          volatile uint8_t Setting_time_out = 0;
    218          
    219          char rfid_temp[16];
    220          char cal_buf[10] = {0,};
    221          uint32_t current_time=0;
    222          
    223          extern tm_struct Now;
    224          
    225          volatile uint16_t adc_ret;
    226          float cal_factor = 0;
    227          float cal_cnt = 0;
    228          void loop(void)
    229          {
    230              static volatile uint32_t time_cnt = 0;
    231              uint32_t loop_time=0,view_time=0,parse_time = 0;
    232          
    233              basic_mode();
    234              Stable_run_flag = 1;
    235          	
    236          	char buf[30] ={0,};
    237          	uint32_t cal_time = 0;
    238          	Water_pcnt1_clear();	
    239          	Water_pcnt2_clear();
    240             
    241          	while(1)
    242              {   
    243                  current_time = millis();
    244                 
    245          		if(calibration_mode == 0)
    246          		{
    247          			if((int32_t)(current_time - loop_time) >= 0)
    248          			{
    249          				loop_time = current_time + MAIN_LOOP_TIME;
    250          					   
    251          				loop_main(); //watchdog
    252          				
    253          				if(Setting_enable == 0 ) 
    254          				  intake_Run(current_time);		//take a water function
    255          				else
    256          				{
    257          				  //setting mode		
    258          				}
    259          		
    260          				Sub_lora_process(); //parse the data from a lora
    261          			}
    262          
    263          			if((int32_t)(current_time - parse_time) >= 0)
    264          			{
    265          				parse_time = current_time + MAIN_LOOP_TIME;
    266          				
    267          				if(uart3_is_empty() == 0)
    268          			  		parse_rfid(uart3_dequeue());  //RFID 		
    269          				else
    270          					rfid = 9999;
    271          			}
    272          			
    273          			if((int32_t)(current_time - view_time) >= 0)
    274          			{ 
    275          			  view_time = current_time + VIEW_LOOP_TIME;
    276          			  R_IR_check();	  //return a IR sensor result
    277          			  R_setting_menu(); 	
    278          			  Now = read_RTC(); //read a rtc value
    279          			}	
    280          			
    281          			parse_lora_packet(); //send a data to Lora
    282          			
    283          			W_Intake.water_temp = Detect_Temp_Data(ADCConvertedValue);
    284                                  
    285                                  if(send_flag == 1)
    286                                  {
    287                                    error_st.status = 0x01;
    288                                    error_st.rf_id = rfid;
    289                                    Send_error_packet(&error_st);
    290                                  }
    291          		}
    292                 
    293          		if(calibration_mode >= 500)
    294          		{
    295          			
    296          			if(((uint32_t)current_time - cal_time) >= 0)
    297          			{
    298          				cal_time = current_time + CAL_LOOP_TIME;
    299          				TM_HD44780_Puts(0,0,"Cal Mode ");
    300          				
    301          				cal_cnt = Water_pcnt1_read();
    302          				cal_factor = (float)(1000/cal_cnt);
    303          				sprintf(buf, "fact %3.2f         ",cal_factor);
    304          				TM_HD44780_Puts(0,1,buf);
    305          				if(SW3 == 0)
    306          				{
    307          					Weight.factor = cal_factor;
    308          					sprintf(cal_buf,"%4.2f",cal_factor);
    309          					FLASH_Unlock();
    310          					FLASH_ErasePage((uint32_t)0x0800FC00);
    311          					for(uint8_t i = 0; i < sizeof(cal_buf); i++)
    312          						FLASH_ProgramHalfWord((uint32_t)0x0800FC00 + (i*2),(uint16_t)cal_buf[i]);
    313          					
    314          					FLASH_Lock();					
    315          					calibration_mode = 0;
    316          				}
    317          			}
    318          			
    319          			if(!R_IR_check2())
    320          			{	
    321          			FET_value[1] = 80;
    322          			FET_value[2] = 80;
    323          			FET_sum[1] += FET_value[1];
    324          			}
    325          		}
    326          	}
    327          }
    328          
    329          uint8_t R_IR_check()
    330          {
    331          	//@@@ @@ @@ (@ @@@)
    332          	return Input_value[0];
    333          }
    334          
    335          uint8_t R_IR_check2()
    336          {
    337          	//@@@ @@ @@ (@ @@@)
    338          	return Input_value[1];
    339          }
    340          
    341          uint8_t R_MaxWater_check()
    342          {
    343              static int ret = 0;
    344              
    345              if (ret == 0)
    346              {
    347                  if (Stable_weight_ch1 > 1000)
    348                  {
    349                    ret = 1;
    350                  }
    351              }
    352              else
    353              {
    354                  if (Stable_weight_ch1 < 900)
    355                  {
    356                    ret = 0;
    357                  }
    358              }
    359              
    360              return ret;
    361          }
    362          
    363          uint16_t R_rfid_check(void)
    364          {
    365          	if(rfid_is_empty() == 0)
    366          	{
    367          		send_rfid = rfid_dequeue();
    368          		return send_rfid;
    369          	}
    370          	else return RFID_UNKNOWN;
    371          }
    372          
    373          void R_rfid_clear(void)
    374          {
    375          	uint8_t loop = 1;
    376          	while(loop)
    377          	{
    378          		if(rfid_is_empty() == 0)
    379          		{
    380          			send_rfid = rfid_dequeue();
    381          		}
    382          		else
    383          		{
    384          			loop = 0;	
    385          		}
    386          	}
    387          }
    388          
    389          
    390          void R_setting_menu(void)
    391          {
    392          	static uint16_t cnt_time = 0;
    393          	static uint8_t view_flag = 0;
    394          
    395          		if(cnt_time++>=30) {
    396          			cnt_time = 0;
    397          
    398          			if(view_flag == 0) view_flag = 1; 
    399          			else if (view_flag== 1) view_flag = 2;
    400          			else if (view_flag== 2) view_flag = 0; 			
    401          		}
    402          	
    403          		if(SW_L[0] == 1 )  
    404          		{
    405          			SW_L[0] = 0;
    406          			SW_S[0] = 0;
    407          			
    408          			if(Setting_time_out == 0)
    409          			{
    410          				 Setting_enable = 1; 
    411          			}
    412          		}
    413          
    414          		if(Setting_enable == 0 ) 
    415          		{
    416          
    417          		} else { 
    418          			setting_mode();
    419          		}		
    420          }
    421          
    422            int main(void)
    423          {  
    424              setup();
    425              setting();
    426          
    427              loop();
    428          }
    429          
    430          
    431          
    432          
    433          
    434          
    435          
    436          
    437          
    438          
    439          
    440          
    441          
    442          
    443          
    444          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   R_IR_check
       0   R_IR_check2
       0   R_MaxWater_check
       8   R_rfid_check
         8   -> rfid_dequeue
         8   -> rfid_is_empty
       8   R_rfid_clear
         8   -> rfid_dequeue
         8   -> rfid_is_empty
       8   R_setting_menu
         0   -> setting_mode
      24   basic_mode
        24   -> TM_HD44780_Puts
        24   -> sprintf
       8   lcd_view_init
         0   -> Delay
         8   -> TM_HD44780_Puts
       8   lcd_view_print
         0   -> TM_HD44780_Puts
         8   -> sprintf
      72   loop
        72   -> Detect_Temp_Data
        72   -> R_setting_menu
        72   -> Send_error_packet
        72   -> Sub_lora_process
        72   -> Water_pcnt1_clear
        72   -> Water_pcnt2_clear
        72   -> basic_mode
        72   -> intake_Run
        72   -> millis
        72   -> parse_lora_packet
        72   -> parse_rfid
        72   -> read_RTC
        72   -> uart3_dequeue
        72   -> uart3_is_empty
       0   loop_main
       8   main
         8   -> loop
         8   -> setting
         8   -> setup
       8   main_view
         0   -> TM_HD44780_Puts
         8   -> sprintf
      16   setting
        16   -> Delay
        16   -> TM_HD44780_Puts
        16   -> __aeabi_d2f
        16   -> atof
        16   -> load_eeprom
        16   -> lora_init
       0   timer_1000ms_loop
       0   timer_100ms_loop
      16   timer_10ms_loop
        16   -> GPIO_ReadInputDataBit
        16   -> SW_check


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_12
       4  ??DataTable21_13
       4  ??DataTable21_14
       4  ??DataTable21_15
       4  ??DataTable21_16
       4  ??DataTable21_17
       4  ??DataTable21_18
       4  ??DataTable21_19
       4  ??DataTable21_2
       4  ??DataTable21_20
       4  ??DataTable21_21
       4  ??DataTable21_22
       4  ??DataTable21_23
       4  ??DataTable21_24
       4  ??DataTable21_25
       4  ??DataTable21_26
       4  ??DataTable21_27
       4  ??DataTable21_28
       4  ??DataTable21_29
       4  ??DataTable21_3
       4  ??DataTable21_30
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
      20  ?_0
      20  ?_1
       8  ?_2
      16  ?_3
      12  ?_4
      16  ?_5
       4  ?_6
       2  FET_FL_cnt
      36  FET_value
          FET_sum
          Input_cnt
       1  FULL_Water_Error
       2  Full_water_check_cnt
       4  Mode_delay
          Stable_water_delay
       1  Mode_flag
       1  NFC_Reader_Ok
       6  R_IR_check
       6  R_IR_check2
      42  R_MaxWater_check
      26  R_rfid_check
      24  R_rfid_clear
      84  R_setting_menu
       4  Setting_time_out
          view_flag
          cnt_time
       1  Stable_ch_flag
       8  Stable_run_flag
          send_flag
          calibration_mode
          current_time
       2  adc_ret
      64  basic_mode
      16  buf_SW_fetvalue
      16  buf_cnt_sensor
      16  buf_menu_num
      12  cal_buf
       4  cal_cnt
       4  cal_factor
       1  k
      42  lcd_view_init
      30  lcd_view_print
     200  loop
       2  loop_main
      22  main
      30  main_view
       4  ret
      16  rfid_temp
       2  send_rfid
     156  setting
       2  test
      12  timer_1000ms_loop
      74  timer_100ms_loop
     232  timer_10ms_loop

 
   155 bytes in section .bss
    20 bytes in section .rodata
 1 252 bytes in section .text
 
 1 252 bytes of CODE  memory
    20 bytes of CONST memory
   155 bytes of DATA  memory

Errors: none
Warnings: 3
