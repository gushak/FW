###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       24/May/2019  11:14:47
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\menu.c
#    Command line =  
#        -f C:\Users\dawoon1\AppData\Local\Temp\EW96BF.tmp
#        (D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\menu.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210C_EVAL -lcN
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\STM3210C-EVAL\List
#        --diag_suppress pa082 -o
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\STM3210C-EVAL\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\
#        -I
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Utilities\STM32_EVAL\
#        -I
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Utilities\STM32_EVAL\STM3210C_EVAL\
#        -Ohs --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.0_2\arm\CMSIS\Core\Include\" -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0_2\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\STM3210C-EVAL\List\menu.lst
#    Object file  =  
#        D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\STM3210C-EVAL\Obj\menu.o
#
###############################################################################

D:\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\menu.c
      1          #include "hw_control.h"
      2          
      3          volatile uint8_t Setting_enable = 0;    
      4          volatile uint8_t SW_S[3] = {0,};	
      5          volatile uint8_t SW_L[3] = {0,};	
      6          volatile uint8_t SW_Push[3] = {0,}; 
      7          volatile uint8_t SW_Cnt[3] = {0,}; 	
      8          
      9          #define SW_LONG_CNT 100	
     10          
     11          void view_test(void);
     12          
     13          void SW_check(void)
     14          {
     15          	if(SW1==0) 
     16            {
     17                if(SW_L[0]==0) //sw8
     18                {	
     19                    if(SW_Cnt[0]++ >= SW_LONG_CNT)	
     20                    { 
     21                      SW_Push[0] = 0;	
     22                      SW_Cnt[0] = 0;		
     23                      SW_L[0] = 1;
     24                    } 
     25                  else 
     26                    {
     27                      SW_Push[0] = 1; 
     28                    }
     29                } 
     30                else 
     31                {
     32                    SW_Push[0] = 1; 
     33                }
     34          	} 
     35            else
     36            {
     37                if(SW_Push[0] == 1)
     38                {
     39                    SW_Push[0] = 0; //@@
     40                    SW_S[0] ++;	
     41                }
     42                SW_Cnt[0] = 0;	
     43          	}
     44          		
     45          	if(SW2==0) 
     46            {
     47                if(SW_L[1] == 0) 
     48                {
     49                    if(SW_Cnt[1]++>= SW_LONG_CNT)
     50                    {
     51                      SW_Push[1] = 0;
     52                      SW_Cnt[1] = 0;
     53                      SW_L[1] = 1;
     54                    }
     55                    else 
     56                    {
     57                      SW_Push[1] = 1;
     58                    }
     59                } 
     60                else 
     61                {
     62                  SW_Push[1] = 1;
     63                }
     64                
     65          	} 
     66            else 
     67            {
     68                if(SW_Push[1] == 1) 
     69                {
     70                  SW_Push[1] = 0;
     71                  SW_S[1] ++ ;
     72                }
     73                SW_Cnt[1] =0;
     74          	} 
     75          	
     76          	if(SW3==0) 
     77            {
     78                if(SW_L[2] == 0) 
     79                {
     80                    if(SW_Cnt[2]++>= SW_LONG_CNT) 
     81                    {
     82                      SW_Push[2] = 0;
     83                      SW_Cnt[2] = 0;  
     84                      SW_L[2] = 1;
     85                    } 
     86                    else 
     87                    {
     88                      SW_Push[2] = 1;
     89                    }
     90                } 
     91                else 
     92                {
     93                  SW_Push[2] = 1;
     94                }	
     95          	}
     96            else 
     97            {
     98                if(SW_Push[2] == 1) 
     99                {
    100                    SW_Push[2] = 0;
    101                    SW_S[2] ++ ;
    102                }
    103                SW_Cnt[2] =0;
    104          	}
    105          }
    106          
    107          #define	MENU_CNT		MAX_EEPROM_ADDRESS          
    108          
    109          volatile uint8_t menu_key_wait=0;  
    110          volatile uint8_t main_key_wait=0;
    111          volatile uint8_t Menu = 0;  
    112          volatile uint8_t setValue = 0;  
    113          
    114          
    115          volatile uint16_t MAX_Value[MAX_EEPROM_ADDRESS]  = { 		//11
    116          												CON_ADDRESS_MAX, 
    117          												CON_WATER_WAIT_DIFF_MAX, 
    118          												CON_WATER_WAIT_TIME_MAX, 
    119          												9999,
    120          												9999,
    121          												COM_RE_ENTER_CNT_MAX,
    122          												9999,
    123          												9999,
    124          												9999,
    125          												9999,
    126                                                                                                          9999,
    127          												CON_WATER_WAIT_MAX,
    128                                                                                                          CON_FARM_CODE_MAX
    129          												};      
    130          
    131          volatile uint16_t MIN_Value[MAX_EEPROM_ADDRESS] = {1,0,0,0,0,0,0,0,0,0,0};
    132          volatile uint16_t Setting_delay = 0;
    133          
    134          extern char buf_menu_num[16]; 
    135          extern volatile uint16_t FET_value[10];
    136          
    137          #define SW_LONG_ADD		50
    138          
    139          char str[100];
    140          void menu_list();
    141          extern volatile uint8_t SW_mode_flag;
    142          
    143          void setting_mode(void)
    144          {
    145          	static uint16_t sw_long_add=0;
    146          	char str[100];
    147          	
    148          	if(Setting_delay !=0) return;
    149          	
    150          	if(Setting_enable == 1) 
    151            {
    152          
    153          		//@@@@ @@@@@ @@
    154          		if(SW1 == 1 && menu_key_wait == 0 ) 
    155          		{   //@@@@@ @@@@@@   	
    156                              Delay(300);				  
    157                              menu_key_wait = 1; SW_L[0] = 0; SW_S[0] = 0;
    158          		}
    159          		else if(SW_L[0] != 0 && menu_key_wait == 1)
    160          		{
    161                  //@@ @@ 
    162                  SW_L[0] = 0;                                            
    163                  Setting_enable = 0;                                                                   
    164                  menu_key_wait = 0;
    165                  main_key_wait = 0;          
    166                  Menu = 0;
    167                  Setting_delay = 20;
    168                      
    169                  return;
    170          		} 
    171          		
    172          		else if(SW_S[0] != 0 && menu_key_wait == 1)                 
    173          		{
    174                  SW_S[0] = 0;                                                        
    175                  
    176                  Setting_enable = 2;
    177                  menu_key_wait = 0;			
    178                  Setting_delay = 5;			
    179                  return;
    180          		}
    181          	
    182          		if(SW_S[1] != 0 || SW_L[1] != 0) 
    183              { 
    184                  Menu++; SW_S[1] = 0; SW_L[1] = 0; 
    185              }  
    186          		
    187          		else if(SW_S[2] != 0 || SW_L[2] != 0)
    188              { 
    189                  Menu--; SW_S[2] = 0; SW_L[2] = 0; 
    190          		}                      
    191          
    192          		if(Menu <= 1) Menu = 1;                                                                                                  
    193          		else if(Menu > MENU_CNT) 
    194              {                                                                                  
    195                  Setting_enable = 0;
    196                  Menu = 0;
    197                  
    198                  main_key_wait = 0;
    199                  SW_L[0] = 0;
    200                  SW_S[0] = 0;
    201          
    202          		  return;		//@@ @@@. 
    203          
    204          		} 
    205          
    206          		sprintf((char*)&str, "%02d>", Menu); 
    207          		TM_HD44780_Puts(0,0, str);
    208          		menu_list();
    209          
    210          		sprintf(str, "  Value : %03d  ", Config.Value[Menu-1]); //10
    211          		TM_HD44780_Puts(0,1, str);	
    212          
    213          	} 
    214            else if(Setting_enable == 2 ) 
    215            {       
    216          		
    217                if(SW1 == 1 && menu_key_wait == 0 ) 
    218                {   
    219                    Setting_delay = 2;
    220                    menu_key_wait = 1; SW_L[0] = 0; SW_S[0] = 0; 	
    221                }
    222                else	if(SW_S[0] != 0 && menu_key_wait == 1)
    223                {                 
    224                    SW_S[0] = 0;                                                           
    225                    SW_L[0] = 0;
    226                    menu_key_wait = 0;
    227                    Setting_enable = 1;                                                   
    228                    save_all_eeprom();
    229                    
    230                    Setting_delay = 2;
    231                    
    232                    //@@@@ @@@ @@ @@@ @@@@ @@@ @@
    233                    SW_S[1] = 0; SW_L[1] = 0;
    234                    SW_S[2] = 0; SW_L[2] = 0;
    235                    
    236                    Menu ++;                                                           
    237                    if(Menu > MENU_CNT) 
    238                    {             
    239                      Setting_enable = 0; 
    240                      Menu = 0;                                                        
    241                      //dp_clear();			                                
    242                      return;
    243                    }
    244                }
    245                else
    246                {			
    247                    
    248                    if(SW2 == 1) //@@@@@ !
    249                    {
    250                      SW_L[1] = 0;	//@@@@
    251                      SW_Cnt[1] = 0;   
    252                    }
    253                    else
    254                    {
    255                      if(SW_L[1] != 0)
    256                      {		//@@ @@@@ !!     
    257                          SW_S[1] = 0;          // @ @@@
    258                          if(sw_long_add ++ > 2) {
    259                            sw_long_add = 0;                 
    260                            if(Config.Value[Menu-1] < (MAX_Value[Menu-1] + SW_LONG_ADD))   
    261                              Config.Value[Menu-1]+=SW_LONG_ADD;
    262                            
    263                            if(Config.Value[Menu-1] >= MAX_Value[Menu-1])   
    264                            {
    265                              Config.Value[Menu-1] = MAX_Value[Menu-1] ;
    266                            }
    267                        }
    268                      } 
    269                      else if(SW_S[1] != 0) 
    270                      {	
    271                          SW_S[1]  = 0;
    272                          if(Config.Value[Menu-1] < MAX_Value[Menu-1])                   
    273                              Config.Value[Menu-1]++;                                      
    274                      }
    275          
    276                    }
    277                    
    278                      
    279                    if(SW3 == 1)                                        
    280                    {
    281                        SW_L[2] = 0;	
    282                        SW_Cnt[2] = 0;  
    283                    }
    284                    else 
    285                    {
    286                        if(SW_L[2] != 0)
    287                        {		 
    288                            SW_S[2] = 0;            
    289                            if(sw_long_add ++ > 2) {           
    290                              sw_long_add = 0;               
    291                              if(Config.Value[Menu-1] >= SW_LONG_ADD)   
    292                              Config.Value[Menu-1]-=SW_LONG_ADD;	     
    293                            }
    294                          
    295                        } 
    296                        else if(SW_S[2] != 0) 
    297                        {	                     
    298                            SW_S[2] = 0;                                   
    299                            if(Config.Value[Menu-1] !=0)               
    300                            Config.Value[Menu-1]--;	               
    301                        }
    302                    }
    303                    sprintf(str, " Set Value:%02d   ", Menu); 
    304                    TM_HD44780_Puts(0,0, str);
    305                              sprintf(str, "  Value : %03d   ", Config.Value[Menu-1]); 
    306                    TM_HD44780_Puts(0,1, str);
    307          
    308                  }
    309          
    310              }
    311          
    312          }
    313          
    314          
    315          //#define COW_NUM	volatile uint8_t Menu = 0;  
    316          void menu_list()
    317          {	
    318          	//TM_HD44780_Puts(3,1, "         ");
    319          	 switch(Menu-1)
    320          	 {
    321          	 case 0: TM_HD44780_Puts(3,0, "Address      "); break;
    322          	 case 1: TM_HD44780_Puts(3,0, "WaterDiff    "); break;
    323          	 case 2: TM_HD44780_Puts(3,0, "WaterDiffT   "); break;	
    324          	 case 3: TM_HD44780_Puts(3,0, "IRCNT   "); break;
    325          	 case 4: TM_HD44780_Puts(3,0, "RFIDCNT      "); break;
    326          	 case 5: TM_HD44780_Puts(3,0, "Re_Enter_T   "); break;
    327          	 case 6: TM_HD44780_Puts(3,0, "RFIDTIMEO   "); break;
    328          	 case 7: TM_HD44780_Puts(3,0, "REENTERCNT  "); break;
    329          	 case 8: TM_HD44780_Puts(3,0, "RFID_TIMEOVER"); break;
    330          	 case 9: TM_HD44780_Puts(3,0, "WEIGHT_TEMP"); break;	
    331          	 case 10: TM_HD44780_Puts(3,0, "Not use       "); break;	
    332          	 case 11: TM_HD44780_Puts(3,0, "CowWait       "); break;	
    333                   case 12: TM_HD44780_Puts(3,0, "FARMCODE   "); break;	
    334          	 default: TM_HD44780_Puts(3,0, "###########  "); break;
    335          	 }
    336          }
    337          
    338          
    339          
    340          /*
    341          
    342          
    343          #define CHANNELwaiting_time			Config.Value[8] 
    344          #define CHANNELwaiting_time_MAX	9000
    345          
    346          #define CON_Water_eat					Config.Value[9] 
    347          #define CON_Water_eat_MAX			1
    348          */
    349          
    350          
    351          
    352          
    353          
    354          
    355          
    356          
    357          
    358          
    359          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SW_check
        16   -> GPIO_ReadInputDataBit
       0   menu_list
         0   -> TM_HD44780_Puts
     120   setting_mode
       120   -> Delay
       120   -> GPIO_ReadInputDataBit
       120   -> TM_HD44780_Puts
       120   -> menu_list
       120   -> save_all_eeprom
       120   -> sprintf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       8  ?_0
      20  ?_1
      16  ?_10
      16  ?_11
      16  ?_12
      12  ?_13
      16  ?_14
      16  ?_15
      12  ?_16
      16  ?_17
      20  ?_2
      20  ?_3
      16  ?_4
      16  ?_5
      16  ?_6
      12  ?_7
      16  ?_8
      16  ?_9
      32  MIN_Value
      56  SW_S
          SW_L
          SW_Push
          SW_Cnt
          Setting_enable
          menu_key_wait
          main_key_wait
          Menu
          Setting_delay
          sw_long_add
          MAX_Value
     206  SW_check
      90  menu_list
       1  setValue
     634  setting_mode
     100  str

 
   101 bytes in section .bss
    88 bytes in section .data
 1 222 bytes in section .text
 
 1 222 bytes of CODE memory
   189 bytes of DATA memory

Errors: none
Warnings: none
