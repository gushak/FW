###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       23/May/2019  16:04:55
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Dawoon\Desktop\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\menu.c
#    Command line =  
#        -f C:\Users\Dawoon\AppData\Local\Temp\EW8CC3.tmp
#        (C:\Users\Dawoon\Desktop\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\menu.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210C_EVAL -lcN
#        C:\Users\Dawoon\Desktop\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\STM3210C-EVAL\List
#        --diag_suppress pa082 -o
#        C:\Users\Dawoon\Desktop\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\STM3210C-EVAL\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Full.h" -I
#        C:\Users\Dawoon\Desktop\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\
#        -I
#        C:\Users\Dawoon\Desktop\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        C:\Users\Dawoon\Desktop\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        C:\Users\Dawoon\Desktop\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Dawoon\Desktop\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Dawoon\Desktop\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Dawoon\Desktop\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\..\..\..\Utilities\STM32_EVAL\STM3210C_EVAL\
#        -Ohs --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\Dawoon\Desktop\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\STM3210C-EVAL\List\menu.lst
#    Object file  =  
#        C:\Users\Dawoon\Desktop\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\STM3210C-EVAL\Obj\menu.o
#
###############################################################################

C:\Users\Dawoon\Desktop\12.@@@@@@@\5.Source\Project\STM_water_measure_double_20170916_kh\STM32F103\menu.c
      1          #include "hw_control.h"
      2          
      3          volatile uint8_t Setting_enable = 0;    
      4          volatile uint8_t SW_S[3] = {0,};	
      5          volatile uint8_t SW_L[3] = {0,};	
      6          volatile uint8_t SW_Push[3] = {0,}; 
      7          volatile uint8_t SW_Cnt[3] = {0,}; 	
      8          
      9          #define SW_LONG_CNT 100	
     10          
     11          void view_test(void);
     12          
     13          void SW_check(void)
     14          {
     15          	if(SW1==0) 
     16            {
     17                if(SW_L[0]==0) //sw8
     18                {	
     19                    if(SW_Cnt[0]++ >= SW_LONG_CNT)	
     20                    { 
     21                      SW_Push[0] = 0;	
     22                      SW_Cnt[0] = 0;		
     23                      SW_L[0] = 1;
     24                    } 
     25                  else 
     26                    {
     27                      SW_Push[0] = 1; 
     28                    }
     29                } 
     30                else 
     31                {
     32                    SW_Push[0] = 1; 
     33                }
     34          	} 
     35            else
     36            {
     37                if(SW_Push[0] == 1)
     38                {
     39                    SW_Push[0] = 0; //@@
     40                    SW_S[0] ++;	
     41                }
     42                SW_Cnt[0] = 0;	
     43          	}
     44          		
     45          	if(SW2==0) 
     46            {
     47                if(SW_L[1] == 0) 
     48                {
     49                    if(SW_Cnt[1]++>= SW_LONG_CNT)
     50                    {
     51                      SW_Push[1] = 0;
     52                      SW_Cnt[1] = 0;
     53                      SW_L[1] = 1;
     54                    }
     55                    else 
     56                    {
     57                      SW_Push[1] = 1;
     58                    }
     59                } 
     60                else 
     61                {
     62                  SW_Push[1] = 1;
     63                }
     64                
     65          	} 
     66            else 
     67            {
     68                if(SW_Push[1] == 1) 
     69                {
     70                  SW_Push[1] = 0;
     71                  SW_S[1] ++ ;
     72                }
     73                SW_Cnt[1] =0;
     74          	} 
     75          	
     76          	if(SW3==0) 
     77            {
     78                if(SW_L[2] == 0) 
     79                {
     80                    if(SW_Cnt[2]++>= SW_LONG_CNT) 
     81                    {
     82                      SW_Push[2] = 0;
     83                      SW_Cnt[2] = 0;  
     84                      SW_L[2] = 1;
     85                    } 
     86                    else 
     87                    {
     88                      SW_Push[2] = 1;
     89                    }
     90                } 
     91                else 
     92                {
     93                  SW_Push[2] = 1;
     94                }	
     95          	}
     96            else 
     97            {
     98                if(SW_Push[2] == 1) 
     99                {
    100                    SW_Push[2] = 0;
    101                    SW_S[2] ++ ;
    102                }
    103                SW_Cnt[2] =0;
    104          	}
    105          }
    106          
    107          #define	MENU_CNT		MAX_EEPROM_ADDRESS          
    108          
    109          volatile uint8_t menu_key_wait=0;  
    110          volatile uint8_t main_key_wait=0;
    111          volatile uint8_t Menu = 0;  
    112          volatile uint8_t setValue = 0;  
    113          
    114          
    115          volatile uint16_t MAX_Value[MAX_EEPROM_ADDRESS]  = { 		//11
    116          												CON_ADDRESS_MAX, 
    117          												CON_WATER_WAIT_DIFF_MAX, 
    118          												CON_WATER_WAIT_TIME_MAX, 
    119          												9999,
    120          												9999,
    121          												COM_RE_ENTER_CNT_MAX,
    122          												9999,
    123          												9999,
    124          												9999,
    125          												9999,
    126                                  9999,
    127          												CON_WATER_WAIT_MAX
    128          												};      
    129          
    130          volatile uint16_t MIN_Value[MAX_EEPROM_ADDRESS] = {1,0,0,0,0,0,0,0,0,0,0};
    131          volatile uint16_t Setting_delay = 0;
    132          
    133          extern char buf_menu_num[16]; 
    134          extern volatile uint16_t FET_value[10];
    135          
    136          #define SW_LONG_ADD		50
    137          
    138          char str[100];
    139          void menu_list();
    140          extern volatile uint8_t SW_mode_flag;
    141          
    142          void setting_mode(void)
    143          {
    144          	static uint16_t sw_long_add=0;
    145          	char str[100];
    146          	
    147          	if(Setting_delay !=0) return;
    148          	
    149          	if(Setting_enable == 1) 
    150            {
    151          
    152          		//@@@@ @@@@@ @@
    153          		if(SW1 == 1 && menu_key_wait == 0 ) 
    154          		{   //@@@@@ @@@@@@   	
    155                  Delay(300);				  
    156                  menu_key_wait = 1; SW_L[0] = 0; SW_S[0] = 0;
    157          		}
    158          		else if(SW_L[0] != 0 && menu_key_wait == 1)
    159          		{
    160                  //@@ @@ 
    161                  SW_L[0] = 0;                                            
    162                  Setting_enable = 0;                                                                   
    163                  menu_key_wait = 0;
    164                  main_key_wait = 0;          
    165                  Menu = 0;
    166                  Setting_delay = 20;
    167                      
    168                  return;
    169          		} 
    170          		
    171          		else if(SW_S[0] != 0 && menu_key_wait == 1)                 
    172          		{
    173                  SW_S[0] = 0;                                                        
    174                  
    175                  Setting_enable = 2;
    176                  menu_key_wait = 0;			
    177                  Setting_delay = 5;			
    178                  return;
    179          		}
    180          	
    181          		if(SW_S[1] != 0 || SW_L[1] != 0) 
    182              { 
    183                  Menu++; SW_S[1] = 0; SW_L[1] = 0; 
    184              }  
    185          		
    186          		else if(SW_S[2] != 0 || SW_L[2] != 0)
    187              { 
    188                  Menu--; SW_S[2] = 0; SW_L[2] = 0; 
    189          		}                      
    190          
    191          		if(Menu <= 1) Menu = 1;                                                                                                  
    192          		else if(Menu > MENU_CNT) 
    193              {                                                                                  
    194                  Setting_enable = 0;
    195                  Menu = 0;
    196                  
    197                  main_key_wait = 0;
    198                  SW_L[0] = 0;
    199                  SW_S[0] = 0;
    200          
    201          		  return;		//@@ @@@. 
    202          
    203          		} 
    204          
    205          		sprintf((char*)&str, "%02d>", Menu); 
    206          		TM_HD44780_Puts(0,0, str);
    207          		menu_list();
    208          
    209          		sprintf(str, "  Value : %03d  ", Config.Value[Menu-1]); //10
    210          		TM_HD44780_Puts(0,1, str);	
    211          
    212          	} 
    213            else if(Setting_enable == 2 ) 
    214            {       
    215          		
    216                if(SW1 == 1 && menu_key_wait == 0 ) 
    217                {   
    218                    Setting_delay = 2;
    219                    menu_key_wait = 1; SW_L[0] = 0; SW_S[0] = 0; 	
    220                }
    221                else	if(SW_S[0] != 0 && menu_key_wait == 1)
    222                {                 
    223                    SW_S[0] = 0;                                                           
    224                    SW_L[0] = 0;
    225                    menu_key_wait = 0;
    226                    Setting_enable = 1;                                                   
    227                    save_all_eeprom();
    228                    
    229                    Setting_delay = 2;
    230                    
    231                    //@@@@ @@@ @@ @@@ @@@@ @@@ @@
    232                    SW_S[1] = 0; SW_L[1] = 0;
    233                    SW_S[2] = 0; SW_L[2] = 0;
    234                    
    235                    Menu ++;                                                           
    236                    if(Menu > MENU_CNT) 
    237                    {             
    238                      Setting_enable = 0; 
    239                      Menu = 0;                                                        
    240                      //dp_clear();			                                
    241                      return;
    242                    }
    243                }
    244                else
    245                {			
    246                    
    247                    if(SW2 == 1) //@@@@@ !
    248                    {
    249                      SW_L[1] = 0;	//@@@@
    250                      SW_Cnt[1] = 0;   
    251                    }
    252                    else
    253                    {
    254                      if(SW_L[1] != 0)
    255                      {		//@@ @@@@ !!     
    256                          SW_S[1] = 0;          // @ @@@
    257                          if(sw_long_add ++ > 2) {
    258                            sw_long_add = 0;                 
    259                            if(Config.Value[Menu-1] < (MAX_Value[Menu-1] + SW_LONG_ADD))   
    260                              Config.Value[Menu-1]+=SW_LONG_ADD;
    261                            
    262                            if(Config.Value[Menu-1] >= MAX_Value[Menu-1])   
    263                            {
    264                              Config.Value[Menu-1] = MAX_Value[Menu-1] ;
    265                            }
    266                        }
    267                      } 
    268                      else if(SW_S[1] != 0) 
    269                      {	
    270                          SW_S[1]  = 0;
    271                          if(Config.Value[Menu-1] < MAX_Value[Menu-1])                   
    272                              Config.Value[Menu-1]++;                                      
    273                      }
    274          
    275                    }
    276                    
    277                      
    278                    if(SW3 == 1)                                        
    279                    {
    280                        SW_L[2] = 0;	
    281                        SW_Cnt[2] = 0;  
    282                    }
    283                    else 
    284                    {
    285                        if(SW_L[2] != 0)
    286                        {		 
    287                            SW_S[2] = 0;            
    288                            if(sw_long_add ++ > 2) {           
    289                              sw_long_add = 0;               
    290                              if(Config.Value[Menu-1] >= SW_LONG_ADD)   
    291                              Config.Value[Menu-1]-=SW_LONG_ADD;	     
    292                            }
    293                          
    294                        } 
    295                        else if(SW_S[2] != 0) 
    296                        {	                     
    297                            SW_S[2] = 0;                                   
    298                            if(Config.Value[Menu-1] !=0)               
    299                            Config.Value[Menu-1]--;	               
    300                        }
    301                    }
    302                    sprintf(str, " Set Value:%02d   ", Menu); 
    303                    TM_HD44780_Puts(0,0, str);
    304                              sprintf(str, "  Value : %03d   ", Config.Value[Menu-1]); 
    305                    TM_HD44780_Puts(0,1, str);
    306          
    307                  }
    308          
    309              }
    310          
    311          }
    312          
    313          
    314          //#define COW_NUM	volatile uint8_t Menu = 0;  
    315          void menu_list()
    316          {	
    317          	//TM_HD44780_Puts(3,1, "         ");
    318          	 switch(Menu-1)
    319          	 {
    320          	 case 0: TM_HD44780_Puts(3,0, "Address      "); break;
    321          	 case 1: TM_HD44780_Puts(3,0, "WaterDiff    "); break;
    322          	 case 2: TM_HD44780_Puts(3,0, "WaterDiffT   "); break;	
    323          	 case 3: TM_HD44780_Puts(3,0, "Not use       "); break;
    324          	 case 4: TM_HD44780_Puts(3,0, "Not use       "); break;
    325          	 case 5: TM_HD44780_Puts(3,0, "Re_Enter_T   "); break;
    326          	 case 6: TM_HD44780_Puts(3,0, "Not use       "); break;
    327          	 case 7: TM_HD44780_Puts(3,0, "Not use       "); break;
    328          	 case 8: TM_HD44780_Puts(3,0, "Not use       "); break;
    329          	 case 9: TM_HD44780_Puts(3,0, "Not use       "); break;	
    330          	 case 10: TM_HD44780_Puts(3,0, "Not use       "); break;	
    331          	 case 11: TM_HD44780_Puts(3,0, "CowWait       "); break;	
    332          	 default: TM_HD44780_Puts(3,0, "###########  "); break;
    333          	 }
    334          }
    335          
    336          
    337          
    338          /*
    339          
    340          
    341          #define CHANNELwaiting_time			Config.Value[8] 
    342          #define CHANNELwaiting_time_MAX	9000
    343          
    344          #define CON_Water_eat					Config.Value[9] 
    345          #define CON_Water_eat_MAX			1
    346          */
    347          
    348          
    349          
    350          
    351          
    352          
    353          
    354          
    355          
    356          
    357          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SW_check
        16   -> GPIO_ReadInputDataBit
       0   menu_list
         0   -> TM_HD44780_Puts
     120   setting_mode
       120   -> Delay
       120   -> GPIO_ReadInputDataBit
       120   -> TM_HD44780_Puts
       120   -> menu_list
       120   -> save_all_eeprom
       120   -> sprintf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       8  ?_0
      20  ?_1
      16  ?_10
      20  ?_2
      20  ?_3
      16  ?_4
      16  ?_5
      16  ?_6
      16  ?_7
      16  ?_8
      16  ?_9
      28  MIN_Value
      52  SW_S
          SW_L
          SW_Push
          SW_Cnt
          Setting_enable
          menu_key_wait
          main_key_wait
          Menu
          Setting_delay
          sw_long_add
          MAX_Value
     206  SW_check
      62  menu_list
       1  setValue
     634  setting_mode
     100  str

 
   101 bytes in section .bss
    80 bytes in section .data
 1 094 bytes in section .text
 
 1 094 bytes of CODE memory
   181 bytes of DATA memory

Errors: none
Warnings: none
